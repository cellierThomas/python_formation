# -*- coding: utf-8 -*-
"""formation_python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13WQrtwT6o3GonMLe77xK8sWjnhcrF_Wd

1ers tests du tuto
"""

7

9.5

3+3

6/2

10%3

"""partie entiere de la division //"""

10//3

testVar = 10
testVar

"""''' pour une string permet de tout echapper automatiquement, pas comme ' ou ", et les sautes de lignes sont respectés"""

chaine = """Et un test
sur plusieurs
lignes facile"""
chaine

"""Détail amusant, la permutation de  2 variables !"""

a = 2
b=12
a,b=b,a
print("a=", a, "et b=", b)

"""Trivia : indiquer qu'une instruction continue sur la ligne suivante avec un antislash \

Connaitre type variable : type( variable)
"""

a = 12486.6
type(a)

a = 71
if a > 50 : 
  print("dans le if")
  a-=1
else:
  print("dans le else")
print("a=", a)

"""1er TP \
Déterminer sur une année est bissextile \
L'astuce : si l'année est multiple de 400 elle est bissextile. \
pour optimiser :\


Si une année n'est pas multiple de 4, on s'arrête là, elle n'est pas bissextile.

Si elle est multiple de 4, on regarde si elle est multiple de 100.

  Si c'est le cas, on regarde si elle est multiple de 400.

    Si c'est le cas, l'année est bissextile.

    Sinon, elle n'est pas bissextile.

  Sinon, elle est bissextile.
"""

annee = input("Indiquez une année : ")
annee = int(annee)

bissextile = False

if annee % 4 == 0 : 
  if annee % 100 == 0 :
    if annee % 400 == 0 :
      bissextile = True
  else : bissextile = True

print(bissextile)

"""Syntaxe while \
while condition : \

Syntaxe for : \
for <var de l'iteration> in <sequence> : 

TRIVIA : \
la signature d'une fonction en python c'est son nom, les parametres ne sont pas prits en compte, pas de polymorphisme possible. \

def func_name ( param, ... ) :

Une lambda doit etre stockee pour etre appelee... \

exemple f = lambda x: x * x \
f(valeur) execute la lambda avec parametre

Doc d'un module importé via import nom_Module (optionnel : as nouveau_nom) \
help("nom_Module") \

appel de fonction via nom_module.fonction()

pour ne récuperer qu'une seule fonction d'un module : \
from module import fonction \
appel de fonction = fonction() \
risques de collision de noms de fonctions de differents modules

if __name__ == "__main__": \
si le fichier executé est le fichier courant, alors __name__ vaut __main__, permet de s'assurer que ce code n'est executé QUE si on lance ce fichier et pas s'il est importé depuis un fichier. Utile pour des TU/TI

Pour un script, rajouter en début de fichier : \
"""

# -*- coding: Latin-1 -*-

# Programme testant si une année, saisie par l'utilisateur, est bissextile ou non

inputOk = False

while inputOk is False :
  try : 
    annee = input("Saisissez une année : ") # On attend que l'utilisateur fournisse l'année qu'il désire tester
    annee = int(annee) # Risque d'erreur si l'utilisateur n'a pas saisi un nombre
    assert annee > 0 # permet de lever une exception assert si la condition n'est pas remplie
  except NameError:
    print("La variable numerateur ou denominateur n'a pas été définie.")
  except TypeError:
    print("La variable numerateur ou denominateur possède un type incompatible avec la division.")
  except ZeroDivisionError:
    print("La variable denominateur est égale à 0.")
  except AssertionError:
    print("L'année saisie est inférieure ou égale à 0.")
  else :
    #execute si tout se passe bien
    inputOk = True
  finally : 
    #pas necessaire ici mais bon, ca existe, comme partout s'execute toujours apres tout le reste
    pass #sert a mettre une instruction mais ne fait rien


if annee % 400 == 0 or (annee % 4 == 0 and annee % 100 != 0):
    print("L'année saisie est bissextile.")
else:
    print("L'année saisie n'est pas bissextile.")

raise nomException(" Message d'erreur a afficher") #permet de lever son exception perso

"""# TP 2"""

# TP 2

import random
import math

argent = 200 #somme initiale

while argent >= 0 :
  print("Somme actuelle : ", argent, "$")

  #verification du parametre de mise
  miseOk = False
  while miseOk is False :
    try :
      mise = input("Combien souhaitez vous miser à la roulette ?")
      mise = int(mise)
      assert mise > 0 , "La mise doit etre supérieure à zéro"
      assert mise < argent, "La mise ne peut pas dépasser l'argent possédé"
    except ValueError : 
      print("Veuillez entrer un entier")
    else : 
      miseOk = True
      argent -= mise

  #verification du parametre de la cible du paris
  cibleOk = False
  while cibleOk is False :
    try :
      numeroCible = int(input("Sur quel numero souhaitez vous miser?"))
      assert numeroCible > 0 , "La cible de la mise ne peut pas être inférieure à zéro"
      assert numeroCible < 49, "La cible de la mise ne peut pas être supérieure à 49"
    except ValueError: 
      print("Veuillez entrer un entier")
    else : 
      cibleOk = True

  #resultat de la roulette
  numeroRoulette = random.randrange(49)
  print("Et le numéro donné par la roulette est le ", numeroRoulette)

  couleurMise = (numeroCible % 2) == 0
  couleurResultat = (numeroRoulette % 2) == 0

  gain = 0
  #calcul des gains
  if couleurMise == couleurResultat : 
    gain = math.ceil(mise)
    argent += gain
    print("Même couleur, vous gagnez", gain, "$")

  if numeroCible == numeroRoulette : 
    gain = mise * 3
    argent += gain
    print("Bon numéro, vous gagnez", mise, "$")

  # Pour eviter de reverser la mise initiale si l'on trouve le bon numero (car on a aussi forcement la bonne couleur)
  # le rajout de la mise est fait ici
  if gain > 0 :	
    argent += mise
  else :
    print("Vous avez perdu ", mise, "$")

#parametrer une string sans concatenation : 
nouvelle_chaine = "Je m'appelle {0} {1} et j'ai {2} ans.".format("Donald", "Duck" , 73)

#plus drole, ca marche sans chiffres entre les accolades 
date = "Dimanche 24 juillet 2011"
heure = "17:00"
print("Cela s'est produit le {}, à {}.".format(date, heure))

#sinon concatené, mais la concatenation ne marche pas s'il y a des int (interpretation du +)
chaine = "Cela s'est produit le " + date + ", à " + heure + "%"
print(chaine)

print(chaine[-1]) # un indice negatif permet de partir de la fin
#chaine[x] = valeur ne fonctionne pas sur les string, mais sur les lists oui

# et ultra explicite
# formatage d'une adresse
adresse = """
{no_rue}, {nom_rue}
 {code_postal} {nom_ville} ({pays})
""".format(no_rue=5, nom_rue="rue des Postes", code_postal=75003, nom_ville="Paris", pays="France")
print(adresse)

#code méthode afficher_flottant donné en exercice
parametre = input("Rentrez un nombre flottant")

#je passe les verifications pour aller directement a l'exercice qui est de manipuler des sequences 
#trouver le point
i = parametre.find(".")
print(parametre[:i+4])

"""nbr de parametre inconnu : \
def fonction(*param):

passer une liste comme un ensemble de params a une fonction : \
func(*list)
"""

#Exercice print
def afficher(*params, sep=' ', fin='\n'):
  chaine = str()
  for param in params :
    chaine = chaine + str(param) + sep

  print( chaine, fin )

afficher ( "plop", 4 , 3, "bli" )

#Stockage de fonction dans un dictionnaire
def fete():
  print("C'est la fête.")

def oiseau():
  print("Fais comme l'oiseau...")

fonctions = {}
fonctions["fete"] = fete # on ne met pas les parenthèses
fonctions["oiseau"] = oiseau
fonctions["fete"]()
fonctions["oiseau"]() # on essaye de l'appeler

def fonction(**param) : #le double etoile indique que chacun des parametres DOIT être nommé 
  pass

#exemple d'appel : fonction ( a=1, b = 2)

def fonction_inconnue(*en_liste, **en_dictionnaire): #les parametres nommés iront dans en_dictionnaire, et les autres dans en_liste
  pass

import os
os.getcwd()

#pour eviter d'avoir a faire un file.close(), une methode plus pratique en cas d'erreur
with open("test.txt", "a") as file :
  file.write("Lorem ipsum")

with open("test.txt", "r") as file :
  content = file.read()
  print(content)

print(file.closed)

os.remove("test.txt")

import pickle

cagnotte = {
  "ami 1":   50,
  "ami 2":   35,
  "ami 3":    5,
  "ami 4":  100,
}
#sauvegarde dans un fichier des données
with open('donnees', 'wb') as fichier:
  mon_pickler = pickle.Pickler(fichier)
  mon_pickler.dump(cagnotte)

del(cagnotte)

#recreation de l'objet depuis les valeurs sauvées dans le fichier
with open('donnees', 'rb') as fichier:
  mon_unpickler = pickle.Unpickler(fichier)
  cagnotte_lue = mon_unpickler.load()

print(cagnotte_lue)

car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

x = car.get("plop")

print(x)